1. this.setState({count: this.state.count + 1}) - The problem with updating state in this way is that it can essentially result in a race condition and updates can be missed. This is best illustrated in an example. Given a counter is starting on 0 and is incremented on click of a button using this code, if the button is clicked 4 times in quick succession, the user would expect the counter to display 4. However depending on the speed with which the button was clicked this may not be the case. This is due to the fact that React state updates are very fast, but not instantaneous, and there is a certain amount of lag time between the update call and the update being completed. When you call this function it will trigger the update to begin, update the count, and trigger a rerender with the new state of count = 1. If you have clicked the button a second time before that rerender and state update has occurred the second click may be lost. A better, and more consistent, way of updating in this way is to pass a function to setState, rather than an object. Ex: this.setState((state) => state.count + 1). This method will ensure the correct count is always kept. 

2. Redux - Redux is used for state management. State in this case, is the current state of the app, what switches are on or off, which form fields have been filled in, are there any errors on the page, etc, etc. Redux offers us a place to store this state and make it accessible everywhere in the app. This allows us to have a single source of truth for our app's state, reducing the likelihood of errors and inconsistencies. To give an example, imagine a social media page like facebook. If you receive a message, a notification appears across the top of the page, and the message itself opens in a message box in the bottom corner of the screen. Both of these, the notification bar and the message box, are two separate components on the page, but are both reliant on the same piece of data, that you have received a message. In order to ensure that you don't have a case of a notification appearing on the top for a message received but no message showing up in the message box, or vice versa. By using redux, we put this information in one single place, which both components then can access and look at, making sure they are always in sync and reacting to the same information.  